Task: Add proper postprocessing effects.
User Interactions:
 - Users can add threejs WEBGPU postprocessing objects to the scene
 - Postprocessors can then be selected and their settings set in the inspector panel
 - User can add multiple postprocessors to the scene, but they are all grouped and run in ONE SINGLE RENDER PASS for performance
 - The order they are added (as visible in the scene tree) is the order they are applied

Notes: 
Start by adding a bloom and dithering postprocessors


Guidelines:
- Colocate files by their features
- Write small modular files, avoid any big files
- Prefer to write dedicated, colocated hooks files over inline hooks in react components
- Use a dark, calming, minimalistic and rounded UI.

Here is an example implementation of bloom, note it is totally unrelated to this codebase and just a reference implementation. Your's must be robust and super efficient to run multiple processors.

"use client";

import React, { useEffect, useRef } from 'react';
import { useFrame, useThree } from '@react-three/fiber';
import { useSnapshot } from 'valtio';
// Postprocessing is not WebGPU compatible in this setup; disable for now
import * as THREE from 'three/webgpu';
// three WebGPU postprocessing via TSL
import { pass } from 'three/tsl';
import { bloom as bloomNode } from 'three/addons/tsl/display/BloomNode.js';
import { visualizerStore } from '@/state/visualizer-store';

const toThreeColor = (rgb: { x: number; y: number; z: number }) => new THREE.Color(rgb.x, rgb.y, rgb.z);

// const blendMap ... removed with postprocessing
// const kernelMap ... removed with postprocessing

const toneMap: Record<string, THREE.ToneMapping> = {
  None: THREE.NoToneMapping,
  Linear: THREE.LinearToneMapping,
  Reinhard: THREE.ReinhardToneMapping,
  Cineon: THREE.CineonToneMapping,
  ACESFilmic: THREE.ACESFilmicToneMapping,
};

const shadowMapType: Record<string, THREE.ShadowMapType> = {
  Basic: THREE.BasicShadowMap,
  PCF: THREE.PCFShadowMap,
  PCFSoft: THREE.PCFSoftShadowMap,
};

export const WorldEffects: React.FC = () => {
  const { gl, scene, camera } = useThree();
  const { world } = useSnapshot(visualizerStore);
  const { bloom } = world;

  // Post-processing refs
  const postRef = useRef<THREE.PostProcessing | null>(null);
  const bloomRef = useRef<any>(null);
  const scenePassColorRef = useRef<any>(null);

  // Update renderer settings when they change
  useEffect(() => {
  // three newer versions removed physicallyCorrectLights; keep for compatibility
    if ('physicallyCorrectLights' in gl) gl.physicallyCorrectLights = true;
    gl.toneMapping = THREE.ACESFilmicToneMapping;
    gl.toneMappingExposure = 1;
    gl.shadowMap.enabled = true;
    gl.shadowMap.type = THREE.PCFSoftShadowMap;
  }, [gl]);

  // Ensure scene fog cleans up when switching types
  useEffect(() => {
    return () => {
      scene.fog = null;
    };
  }, [scene]);

  // Setup/teardown WebGPU bloom post-processing. Only enable in material shading mode.
  useEffect(() => {
    const dispose = () => {
      if (postRef.current && typeof (postRef.current as any).dispose === 'function') {
        try { (postRef.current as any).dispose(); } catch {}
      }
      postRef.current = null;
      bloomRef.current = null;
      scenePassColorRef.current = null;
    };

    // enable only when bloom is on and we are in material shading mode
    // Only available with WebGPU renderer
    if (!(gl as any)?.isWebGPURenderer || !bloom.enabled) {
      dispose();
      return;
    }

    try {
      const post = new (THREE as any).PostProcessing(gl as any);
      // Build a scene pass and add bloom on top of the color output
      const scenePass = pass(scene as any, camera as any);
      const scenePassColor = (scenePass as any).getTextureNode('output');
      const bloomPass = bloomNode(scenePassColor);

      // Initial params from settings
      if (bloomPass.threshold) bloomPass.threshold.value = bloom.threshold;
      if (bloomPass.strength) bloomPass.strength.value = bloom.strength;
      if (bloomPass.radius) bloomPass.radius.value = Math.max(0, Math.min(3, bloom.radius));

      // Compose and assign
      post.outputNode = (scenePassColor as any).add(bloomPass);

      postRef.current = post;
      bloomRef.current = bloomPass;
      scenePassColorRef.current = scenePassColor;
    } catch (e) {
      console.warn('Bloom postprocessing init failed:', e);
      dispose();
    }

    return dispose;
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gl, scene, camera, bloom.enabled]);

  useEffect(() => {
    if (!bloom.enabled || !bloomRef.current) return;

    if (bloomRef.current.threshold) bloomRef.current.threshold.value = bloom.threshold;
    if (bloomRef.current.strength) bloomRef.current.strength.value = bloom.strength;
    if (bloomRef.current.radius) bloomRef.current.radius.value = Math.max(0, Math.min(3, bloom.radius));
  }, [bloom.enabled, bloom.threshold, bloom.strength, bloom.radius]);

  // Drive post-processing each frame (after the default r3f render)
  useFrame(() => {
    if (postRef.current) {
      postRef.current.render();
    } else {
      // Fallback: if no postprocessing chain is active, ensure the renderer still draws the scene.
      // In some WebGPU setups the default React-Three-Fiber render path can be bypassed; call render explicitly.
      try {
        (gl as any).render(scene, camera);
      } catch {
        // ignore render errors here
      }
    }
  }, 1);

  return (
    <>
    </>
  );
};

export default WorldEffects;
