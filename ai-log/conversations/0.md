Task: Alright refactor the learnings from this editor into building a proper actual editor.
User Interactions:
 - On the left is a floating scene tree panel which allows users to select items on the scene
 - On the bottom is a timeline with a playhead, where users can seek by either dragging the playhead or clicking anywhere on the ruler, below the clip are the keyframe diamonds placed, per property and object separated
 - users can drag & drop audio on the timeline to switch the audio clip
 - It shows the audio clip with it's waveform in the timeline
 - on the right is a floating "inspector" panel which allows to modify selected items
 - on the top is a "compose bar" floating, which allows to quickly add things:
  * Primitives (Cube, Pyramid, Torus)
  * Shaders (Will be self contained plane components that contain TSL shader code, the example one will be the rainbow shader)
  * Waveform Instancing
  * Postprocessors (Will be self contained TSL postprocessing effects that modify the scene)
  * Cameras
 - AnimeJS has keyframe capabilities and it should be possible to set keyframes of ALL objects at any given moment, keyframeable properties:
  - Transforms (Position XYZ, Rotation XYZ, Scale XYZ)
  - Materials (color, roughness, metalness, emissivecolor, emissive intensity)
  - Visibility (bool)
 - The inspector panel has multiple options to manage objects:
  * uses drag-input for numeric values (transform values). Show XYZ type values like this in a row:
  X [input<keyframe diamond>] Y[input<keyframe diamond>] Z[input<keyframe diamond>]
  * all other values should generally be 1 per row
  * Primitives: Transform, Material
  * Shaders have shader-specific controls (each shader can expose different controls), some may react to the audio clip, some may have additional color, speed, whatever controls
  * Waveform Instancers allow users to select a primitive that is in the scene and uses instancing to build a waveform animation out of that. Users can for example attach a cube and the instancer options can ask: radial, linear instancing, amount of instances, etc.
  * Cameras: Transform (KEYFRAMEABLE!!), isActive (KEYFRAMEABLE!). This way users can move a camera and then switch between cameras with keyframes, allowing for interesting compositions
  * Postprocessors also similar to shaders have each different settings. E.g. a dither postprocessor has different settings than a bloom one

State Management:
 - use jotai for cold storage
 - state should be serializable to a zip file, which includes the whole state as well as the assets (audio for example)

Guidelines:
- Colocate files by their features
- TSL and TSL WebGPU only. Never try to fake it by using WGSL or webgl.
- Write small modular files, avoid any big files
- Prefer to write dedicated, colocated hooks files over inline hooks in react components
- Use a dark, calming, minimalistic and rounded UI.
- Do not run a dev server at the end. I always have one running already.